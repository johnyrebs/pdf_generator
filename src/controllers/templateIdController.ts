/**
 * PDF Generator API 3.1.1Lib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import { ForbiddenError } from '../errors/forbiddenError';
import { InternalServerError } from '../errors/internalServerError';
import { NotFoundError } from '../errors/notFoundError';
import { UnauthorizedError } from '../errors/unauthorizedError';
import { UnprocessableEntityError } from '../errors/unprocessableEntityError';
import { DocumentData, documentDataSchema } from '../models/documentData';
import {
  GenerateDocumentRequest,
  generateDocumentRequestSchema,
} from '../models/generateDocumentRequest';
import {
  OpenEditorRequest,
  openEditorRequestSchema,
} from '../models/openEditorRequest';
import {
  ReturnsAnURLWhichYouCanUseToRedirectYourUserToTheEditorOrUseAsIframeSource,
  returnsAnURLWhichYouCanUseToRedirectYourUserToTheEditorOrUseAsIframeSourceSchema,
} from '../models/returnsAnURLWhichYouCanUseToRedirectYourUserToTheEditorOrUseAsIframeSource';
import {
  TemplateConfigurationAsJSONObject,
  templateConfigurationAsJSONObjectSchema,
} from '../models/templateConfigurationAsJSONObject';
import {
  TheRequestWasSuccessfullyExecuted,
  theRequestWasSuccessfullyExecutedSchema,
} from '../models/theRequestWasSuccessfullyExecuted';
import {
  UpdateTemplateRequest,
  updateTemplateRequestSchema,
} from '../models/updateTemplateRequest';
import { number, string } from '../schema';
import { BaseController } from './baseController';

export class TemplateIdController extends BaseController {
  /**
   * Returns template configuration
   *
   * @param templateId (Required) Template unique identifier
   * @return Response from the API call
   */
  async getTemplate(
    templateId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TemplateConfigurationAsJSONObject>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ templateId: [templateId, number()] });
    req.appendTemplatePath`/templates/${mapped.templateId}`;
    req.throwOn(401, UnauthorizedError, 'Unauthorized');
    req.throwOn(403, ForbiddenError, 'Forbidden');
    req.throwOn(404, NotFoundError, 'Not Found');
    req.throwOn(422, UnprocessableEntityError, 'Unprocessable Entity (WebDAV) (RFC 4918)');
    req.throwOn(500, InternalServerError, 'Internal Server Error');
    return req.callAsJson(
      templateConfigurationAsJSONObjectSchema,
      requestOptions
    );
  }

  /**
   * Updates template configuration. The template configuration for pages and layout must be complete as
   * the entire configuration is replaced and not merged.
   *
   * @param templateId   (Required) Template unique identifier
   * @param contentType
   * @param body
   * @return Response from the API call
   */
  async updateTemplate(
    templateId: number,
    contentType: string,
    body: UpdateTemplateRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TemplateConfigurationAsJSONObject>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      templateId: [templateId, number()],
      contentType: [contentType, string()],
      body: [body, updateTemplateRequestSchema],
    });
    req.header('Content-Type', mapped.contentType);
    req.json(mapped.body);
    req.appendTemplatePath`/templates/${mapped.templateId}`;
    req.throwOn(401, UnauthorizedError, 'Unauthorized');
    req.throwOn(403, ForbiddenError, 'Forbidden');
    req.throwOn(404, NotFoundError, 'Not Found');
    req.throwOn(422, UnprocessableEntityError, 'Unprocessable Entity (WebDAV) (RFC 4918)');
    req.throwOn(500, InternalServerError, 'Internal Server Error');
    return req.callAsJson(
      templateConfigurationAsJSONObjectSchema,
      requestOptions
    );
  }

  /**
   * Deletes the template from workspace
   *
   * @param templateId (Required) Template unique identifier
   * @return Response from the API call
   */
  async deleteTemplate(
    templateId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TheRequestWasSuccessfullyExecuted>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ templateId: [templateId, number()] });
    req.appendTemplatePath`/templates/${mapped.templateId}`;
    req.throwOn(401, UnauthorizedError, 'Unauthorized');
    req.throwOn(403, ForbiddenError, 'Forbidden');
    req.throwOn(404, NotFoundError, 'Not Found');
    req.throwOn(422, UnprocessableEntityError, 'Unprocessable Entity (WebDAV) (RFC 4918)');
    req.throwOn(500, InternalServerError, 'Internal Server Error');
    return req.callAsJson(
      theRequestWasSuccessfullyExecutedSchema,
      requestOptions
    );
  }

  /**
   * Creates a copy of a template to the workspace specified in authentication parameters.
   *
   * @param name       Name for the copied template. If name is not specified then the original name is used.
   * @param templateId (Required) Template unique identifier
   * @return Response from the API call
   */
  async copyTemplate(
    name: string,
    templateId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TemplateConfigurationAsJSONObject>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      name: [name, string()],
      templateId: [templateId, number()],
    });
    req.query('name', mapped.name);
    req.appendTemplatePath`/templates/${mapped.templateId}/copy`;
    req.throwOn(401, UnauthorizedError, 'Unauthorized');
    req.throwOn(403, ForbiddenError, 'Forbidden');
    req.throwOn(404, NotFoundError, 'Not Found');
    req.throwOn(422, UnprocessableEntityError, 'Unprocessable Entity (WebDAV) (RFC 4918)');
    req.throwOn(500, InternalServerError, 'Internal Server Error');
    return req.callAsJson(
      templateConfigurationAsJSONObjectSchema,
      requestOptions
    );
  }

  /**
   * Returns an unique URL which you can use to redirect your user to the editor from your application or
   * use the generated URL as iframe source to show the editor within your application.
   *
   *
   * @param language     Specify the editor UI language. Defaults to organization editor
   *                                                 language.
   * @param templateId   (Required) Template unique identifier
   * @param contentType
   * @param body
   * @return Response from the API call
   */
  async openEditor(
    language: string,
    templateId: number,
    contentType: string,
    body: OpenEditorRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReturnsAnURLWhichYouCanUseToRedirectYourUserToTheEditorOrUseAsIframeSource>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      language: [language, string()],
      templateId: [templateId, number()],
      contentType: [contentType, string()],
      body: [body, openEditorRequestSchema],
    });
    req.header('Content-Type', mapped.contentType);
    req.query('language', mapped.language);
    req.json(mapped.body);
    req.appendTemplatePath`/templates/${mapped.templateId}/editor`;
    req.throwOn(401, UnauthorizedError, 'Unauthorized');
    req.throwOn(403, ForbiddenError, 'Forbidden');
    req.throwOn(404, NotFoundError, 'Not Found');
    req.throwOn(422, UnprocessableEntityError, 'Unprocessable Entity (WebDAV) (RFC 4918)');
    req.throwOn(500, InternalServerError, 'Internal Server Error');
    return req.callAsJson(
      returnsAnURLWhichYouCanUseToRedirectYourUserToTheEditorOrUseAsIframeSourceSchema,
      requestOptions
    );
  }

  /**
   * Merges template with data and returns base64 encoded document or a public URL to a document. You can
   * send json encoded data in request body or a public URL to your json file as the data parameter. NB!
   * When the public URL option is used, the document is stored for 30 days and automatically deleted.
   *
   * @param name         Document name, returned in the meta data.
   * @param format       Document format. The zip option will return a ZIP file with
   *                                                       PDF files.
   * @param output       Response format. With the url option, the document is
   *                                                       stored for 30 days and automatically deleted.
   * @param templateId   (Required) Template unique identifier
   * @param contentType
   * @param body
   * @return Response from the API call
   */
  async generateDocument(
    name: string,
    format: string,
    output: string,
    templateId: number,
    contentType: string,
    body: GenerateDocumentRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<DocumentData>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      name: [name, string()],
      format: [format, string()],
      output: [output, string()],
      templateId: [templateId, number()],
      contentType: [contentType, string()],
      body: [body, generateDocumentRequestSchema],
    });
    req.header('Content-Type', mapped.contentType);
    req.query('name', mapped.name);
    req.query('format', mapped.format);
    req.query('output', mapped.output);
    req.json(mapped.body);
    req.appendTemplatePath`/templates/${mapped.templateId}/output`;
    req.throwOn(401, UnauthorizedError, 'Unauthorized');
    req.throwOn(403, ForbiddenError, 'Forbidden');
    req.throwOn(404, NotFoundError, 'Not Found');
    req.throwOn(422, UnprocessableEntityError, 'Unprocessable Entity (WebDAV) (RFC 4918)');
    req.throwOn(500, InternalServerError, 'Internal Server Error');
    return req.callAsJson(documentDataSchema, requestOptions);
  }
}
