/**
 * PDF Generator API 3.1.1Lib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import { ForbiddenError } from '../errors/forbiddenError';
import { InternalServerError } from '../errors/internalServerError';
import { NotFoundError } from '../errors/notFoundError';
import { UnauthorizedError } from '../errors/unauthorizedError';
import { UnprocessableEntityError } from '../errors/unprocessableEntityError';
import {
  AnArrayOfTemplateObjects,
  anArrayOfTemplateObjectsSchema,
} from '../models/anArrayOfTemplateObjects';
import {
  CreateTemplateRequest,
  createTemplateRequestSchema,
} from '../models/createTemplateRequest';
import { DocumentData, documentDataSchema } from '../models/documentData';
import {
  GenerateDocumentMultipleTemplatesRequest,
  generateDocumentMultipleTemplatesRequestSchema,
} from '../models/generateDocumentMultipleTemplatesRequest';
import {
  TemplateConfigurationAsJSONObject,
  templateConfigurationAsJSONObjectSchema,
} from '../models/templateConfigurationAsJSONObject';
import { array, string } from '../schema';
import { BaseController } from './baseController';

export class TemplatesController extends BaseController {
  /**
   * Returns a list of templates available for the authenticated workspace
   *
   * @return Response from the API call
   */
  async getTemplates(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AnArrayOfTemplateObjects>> {
    const req = this.createRequest('GET', '/templates');
    req.throwOn(401, UnauthorizedError, 'Unauthorized');
    req.throwOn(403, ForbiddenError, 'Forbidden');
    req.throwOn(404, NotFoundError, 'Not Found');
    req.throwOn(422, UnprocessableEntityError, 'Unprocessable Entity (WebDAV) (RFC 4918)');
    req.throwOn(500, InternalServerError, 'Internal Server Error');
    return req.callAsJson(anArrayOfTemplateObjectsSchema, requestOptions);
  }

  /**
   * Creates a new template. If template configuration is not specified in the request body then an empty
   * template is created. Template is placed to the workspace specified in authentication params.
   * Template configuration must be sent in the request body.
   *
   * @param contentType
   * @param body
   * @return Response from the API call
   */
  async createTemplate(
    contentType: string,
    body: CreateTemplateRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TemplateConfigurationAsJSONObject>> {
    const req = this.createRequest('POST', '/templates');
    const mapped = req.prepareArgs({
      contentType: [contentType, string()],
      body: [body, createTemplateRequestSchema],
    });
    req.header('Content-Type', mapped.contentType);
    req.json(mapped.body);
    req.throwOn(401, UnauthorizedError, 'Unauthorized');
    req.throwOn(403, ForbiddenError, 'Forbidden');
    req.throwOn(404, NotFoundError, 'Not Found');
    req.throwOn(422, UnprocessableEntityError, 'Unprocessable Entity (WebDAV) (RFC 4918)');
    req.throwOn(500, InternalServerError, 'Internal Server Error');
    return req.callAsJson(
      templateConfigurationAsJSONObjectSchema,
      requestOptions
    );
  }

  /**
   * Allows to merge multiples template with data and returns base64 encoded document or public URL to a
   * document. NB! When the public URL option is used, the document is stored for 30 days and
   * automatically deleted.
   *
   * @param name         Document name, returned in the meta data.
   * @param format       Document format. The zip option will return a
   *                                                                   ZIP file with PDF files.
   * @param output       Response format. With the url option, the
   *                                                                   document is stored for 30 days and automatically
   *                                                                   deleted.
   * @param contentType
   * @param body
   * @return Response from the API call
   */
  async generateDocumentMultipleTemplates(
    name: string,
    format: string,
    output: string,
    contentType: string,
    body: GenerateDocumentMultipleTemplatesRequest[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<DocumentData>> {
    const req = this.createRequest('POST', '/templates/output');
    const mapped = req.prepareArgs({
      name: [name, string()],
      format: [format, string()],
      output: [output, string()],
      contentType: [contentType, string()],
      body: [body, array(generateDocumentMultipleTemplatesRequestSchema)],
    });
    req.header('Content-Type', mapped.contentType);
    req.query('name', mapped.name);
    req.query('format', mapped.format);
    req.query('output', mapped.output);
    req.json(mapped.body);
    req.throwOn(401, UnauthorizedError, 'Unauthorized');
    req.throwOn(403, ForbiddenError, 'Forbidden');
    req.throwOn(404, NotFoundError, 'Not Found');
    req.throwOn(422, UnprocessableEntityError, 'Unprocessable Entity (WebDAV) (RFC 4918)');
    req.throwOn(500, InternalServerError, 'Internal Server Error');
    return req.callAsJson(documentDataSchema, requestOptions);
  }
}
